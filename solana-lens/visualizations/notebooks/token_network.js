const notebookData = {
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "title-cell",
        "language": "markdown"
      },
      "source": [
        "# Token Creator Network Visualization",
        "",
        "An interactive visualization showing relationships between token creators and tokens on Solana"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "imports-cell",
        "language": "javascript"
      },
      "source": [
        "// Import libraries",
        "import * as d3 from \"d3\"",
        "import { loadNetworkGraph, loadVisualizationData } from \"../utils/data-loader.js\"",
        "import { fetchFromCollector, hasCollector } from \"../utils/collector-connector.js\""
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "data-source-cell",
        "language": "javascript"
      },
      "source": [
        "// Data source selection",
        "viewof dataSource = Inputs.radio(",
        "  [\"Sample Data\", \"Upload File\", \"Fetch from API\"],",
        "  {value: \"Sample Data\", label: \"Data Source\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "file-upload-cell",
        "language": "javascript"
      },
      "source": [
        "// File upload component",
        "viewof fileUpload = Inputs.file({",
        "  label: \"Upload JSON file (nodes/links)\", ",
        "  accept: \".json\", ",
        "  required: dataSource === \"Upload File\"",
        "})"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "node-filter-cell",
        "language": "javascript"
      },
      "source": [
        "// Filter for node types",
        "viewof nodeTypeFilter = Inputs.checkbox(",
        "  [\"creator\", \"token\", \"suspicious\", \"verified\"],",
        "  { value: [\"creator\", \"token\", \"suspicious\", \"verified\"], label: \"Node Types\" }",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "connections-filter-cell",
        "language": "javascript"
      },
      "source": [
        "// Filter for minimum connections",
        "viewof minConnections = Inputs.range(",
        "  [0, 10],",
        "  { value: 1, step: 1, label: \"Minimum Connections\" }",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "data-loading-cell",
        "language": "javascript"
      },
      "source": [
        "// Data loading function based on selected source",
        "data = {",
        "  if (dataSource === \"Sample Data\") {",
        "    return tokenNetworkSampleData;",
        "  } else if (dataSource === \"Upload File\") {",
        "    // Check if file is uploaded",
        "    if (!fileUpload) {",
        "      return { nodes: [], links: [] };",
        "    }",
        "    ",
        "    try {",
        "      // Parse uploaded file",
        "      const fileContent = fileUpload;",
        "      const jsonData = JSON.parse(fileContent.text());",
        "      ",
        "      // Basic validation",
        "      if (!jsonData.nodes || !jsonData.links || !Array.isArray(jsonData.nodes) || !Array.isArray(jsonData.links)) {",
        "        throw new Error(\"Invalid data format. Expected {nodes: [], links: []}\");",
        "      }",
        "      ",
        "      return jsonData;",
        "    } catch (error) {",
        "      console.error(\"Error loading file:\", error);",
        "      return { nodes: [], links: [] };",
        "    }",
        "  } else if (dataSource === \"Fetch from API\") {",
        "    // Use real data from token network collector",
        "    try {",
        "      if (!hasCollector('tokenNetwork')) {",
        "        throw new Error('Token network collector not available');",
        "      }",
        "      ",
        "      // Show loading indicator",
        "      const loadingMsg = md`**Loading token creator data from blockchain...**  \nThis may take a moment as we analyze token creation patterns.`;",
        "      yield loadingMsg;",
        "      ",
        "      // Fetch real token network data",
        "      const networkData = await fetchFromCollector('tokenNetwork', 'analyze_token_creators', 200); // Limit to 200 tokens",
        "      ",
        "      // Use real data if available and properly formatted",
        "      if (networkData && networkData.nodes && networkData.links && ",
        "          networkData.nodes.length > 0 && networkData.links.length > 0) {",
        "        return networkData;",
        "      }",
        "      ",
        "      // Log info about fallback",
        "      console.log('No token network data found or improperly formatted, using sample data');",
        "      return {",
        "        ...tokenNetworkSampleData,",
        "        _note: 'Sample data (real data unavailable or insufficient)'",
        "      };",
        "    } catch (error) {",
        "      console.error(\"Error loading token network data:\", error);",
        "      return {",
        "        ...tokenNetworkSampleData,",
        "        _error: error.message,",
        "        _note: 'Sample data due to collector error'",
        "      };",
        "    }",
        "  }",
        "  ",
        "  // Default fallback",
        "  return { nodes: [], links: [] };",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "filtered-data-cell",
        "language": "javascript"
      },
      "source": [
        "// Filtered data based on user inputs",
        "filteredData = {",
        "  // Handle empty data case",
        "  if (!data || !data.nodes || !data.links) {",
        "    return { nodes: [], links: [] };",
        "  }",
        "  ",
        "  // Filter nodes by selected types",
        "  const filteredNodes = data.nodes.filter(node => ",
        "    node && node.type && nodeTypeFilter.includes(node.type)",
        "  );",
        "  ",
        "  // Create a Set of filtered node IDs for quick lookup",
        "  const filteredNodeIds = new Set(filteredNodes.map(n => n.id));",
        "",
        "  // Filter links to only include connections between filtered nodes",
        "  const filteredLinks = data.links.filter(link =>",
        "    link && link.source && link.target &&",
        "    filteredNodeIds.has(typeof link.source === 'object' ? link.source.id : link.source) && ",
        "    filteredNodeIds.has(typeof link.target === 'object' ? link.target.id : link.target)",
        "  );",
        "",
        "  // Count connections for each node",
        "  const nodeConnections = {};",
        "  filteredLinks.forEach(link => {",
        "    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;",
        "    const targetId = typeof link.target === 'object' ? link.target.id : link.target;",
        "    ",
        "    nodeConnections[sourceId] = (nodeConnections[sourceId] || 0) + 1;",
        "    nodeConnections[targetId] = (nodeConnections[targetId] || 0) + 1;",
        "  });",
        "",
        "  // Further filter nodes based on minimum connections",
        "  const finalNodes = filteredNodes.filter(node => ",
        "    (nodeConnections[node.id] || 0) >= minConnections",
        "  );",
        "  ",
        "  // Create another Set for final filtered node IDs",
        "  const finalNodeIds = new Set(finalNodes.map(n => n.id));",
        "  ",
        "  // Final filtering of links",
        "  const finalLinks = filteredLinks.filter(link => {",
        "    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;",
        "    const targetId = typeof link.target === 'object' ? link.target.id : link.target;",
        "    ",
        "    return finalNodeIds.has(sourceId) && finalNodeIds.has(targetId);",
        "  });",
        "",
        "  return { ",
        "    nodes: finalNodes, ",
        "    links: finalLinks.map(link => ({",
        "      ...link,",
        "      source: typeof link.source === 'object' ? link.source.id : link.source,",
        "      target: typeof link.target === 'object' ? link.target.id : link.target",
        "    }))",
        "  };",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "network-stats-cell",
        "language": "javascript"
      },
      "source": [
        "// Network stats",
        "networkStats = {",
        "  if (!filteredData.nodes.length) {",
        "    return md`No nodes to display based on current filters.`;",
        "  }",
        "",
        "  const creatorCount = filteredData.nodes.filter(n => n.type === 'creator').length;",
        "  const tokenCount = filteredData.nodes.filter(n => n.type === 'token').length;",
        "  const suspiciousCount = filteredData.nodes.filter(n => n.type === 'suspicious').length;",
        "  const verifiedCount = filteredData.nodes.filter(n => n.type === 'verified').length;",
        "  ",
        "  return md`",
        "  ## Network Statistics",
        "  ",
        "  - **Nodes**: ${filteredData.nodes.length}",
        "  - **Links**: ${filteredData.links.length}",
        "  - **Creators**: ${creatorCount}",
        "  - **Tokens**: ${tokenCount}",
        "  - **Suspicious Entities**: ${suspiciousCount}",
        "  - **Verified Entities**: ${verifiedCount}",
        "  `;",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "network-visualization-cell",
        "language": "javascript"
      },
      "source": [
        "// Network visualization using D3 force simulation",
        "tokenNetworkChart = {",
        "  if (!filteredData.nodes.length) {",
        "    return html`<div style=\"padding: 20px; text-align: center; background: #f9f9f9; border-radius: 5px;\">",
        "      <h3>No data to display based on current filters</h3>",
        "      <p>Try adjusting the filters above or selecting a different data source.</p>",
        "    </div>`;",
        "  }",
        "",
        "  const width = 800;",
        "  const height = 600;",
        "  ",
        "  // Prepare a copy of the data for the simulation",
        "  const nodes = filteredData.nodes.map(d => ({...d}));",
        "  const links = filteredData.links.map(d => ({...d}));",
        "",
        "  // Color scale for different node types",
        "  const colorScale = d3.scaleOrdinal()",
        "    .domain(['creator', 'token', 'suspicious', 'verified'])",
        "    .range(['#4e79a7', '#f28e2c', '#e15759', '#59a14f']);",
        "",
        "  // Node size scale based on value (or default to 1)",
        "  const sizeScale = d3.scaleLinear()",
        "    .domain([",
        "      d3.min(nodes, d => d.value || 1),",
        "      d3.max(nodes, d => d.value || 1)",
        "    ])",
        "    .range([5, 20]);",
        "",
        "  // Create SVG container",
        "  const svg = d3.create(\"svg\")",
        "    .attr(\"viewBox\", [0, 0, width, height])",
        "    .attr(\"width\", width)",
        "    .attr(\"height\", height)",
        "    .attr(\"style\", \"max-width: 100%; height: auto; font: 10px sans-serif;\");",
        "",
        "  // Add zoom behavior",
        "  const zoom = d3.zoom()",
        "    .scaleExtent([0.1, 8])",
        "    .on(\"zoom\", (event) => {",
        "      g.attr(\"transform\", event.transform);",
        "    });",
        "    ",
        "  svg.call(zoom);",
        "  ",
        "  // Create a group for the graph elements",
        "  const g = svg.append(\"g\");",
        "",
        "  // Create links",
        "  const link = g.append(\"g\")",
        "    .attr(\"stroke\", \"#999\")",
        "    .attr(\"stroke-opacity\", 0.6)",
        "    .selectAll(\"line\")",
        "    .data(links)",
        "    .join(\"line\")",
        "    .attr(\"stroke-width\", d => Math.sqrt(d.value || 1));",
        "",
        "  // Create nodes",
        "  const node = g.append(\"g\")",
        "    .selectAll(\".node\")",
        "    .data(nodes)",
        "    .join(\"g\")",
        "    .attr(\"class\", \"node\")",
        "    .call(drag(simulation));",
        "",
        "  // Add circles to nodes",
        "  node.append(\"circle\")",
        "    .attr(\"r\", d => sizeScale(d.value || 1))",
        "    .attr(\"fill\", d => colorScale(d.type))",
        "    .attr(\"stroke\", \"#fff\")",
        "    .attr(\"stroke-width\", 1.5);",
        "",
        "  // Add tooltips ",
        "  node.append(\"title\")",
        "    .text(d => {",
        "      const details = [",
        "        `Type: ${d.type}`,",
        "        `ID: ${d.id}`",
        "      ];",
        "      ",
        "      if (d.symbol) details.push(`Symbol: ${d.symbol}`);",
        "      if (d.value) details.push(`Value: ${d.value}`);",
        "      ",
        "      return details.join('\\n');",
        "    });",
        "",
        "  // Add small labels to important nodes",
        "  node.filter(d => d.value > 8 || d.type === 'suspicious')",
        "    .append(\"text\")",
        "    .attr(\"dx\", d => sizeScale(d.value || 1) + 2)",
        "    .attr(\"dy\", \".35em\")",
        "    .text(d => d.id.substring(0, 8) + (d.id.length > 8 ? \"...\" : \"\"));",
        "",
        "  // Create simulation",
        "  const simulation = d3.forceSimulation(nodes)",
        "    .force(\"link\", d3.forceLink(links).id(d => d.id).distance(100))",
        "    .force(\"charge\", d3.forceManyBody().strength(-200))",
        "    .force(\"center\", d3.forceCenter(width / 2, height / 2))",
        "    .force(\"collision\", d3.forceCollide().radius(d => sizeScale(d.value || 1) + 5))",
        "    .on(\"tick\", ticked);",
        "",
        "  // Drag function",
        "  function drag(simulation) {",
        "    function dragstarted(event, d) {",
        "      if (!event.active) simulation.alphaTarget(0.3).restart();",
        "      d.fx = d.x;",
        "      d.fy = d.y;",
        "    }",
        "    ",
        "    function dragged(event, d) {",
        "      d.fx = event.x;",
        "      d.fy = event.y;",
        "    }",
        "    ",
        "    function dragended(event, d) {",
        "      if (!event.active) simulation.alphaTarget(0);",
        "      d.fx = null;",
        "      d.fy = null;",
        "    }",
        "    ",
        "    return d3.drag()",
        "      .on(\"start\", dragstarted)",
        "      .on(\"drag\", dragged)",
        "      .on(\"end\", dragended);",
        "  }",
        "",
        "  // Tick function for updating positions",
        "  function ticked() {",
        "    link",
        "      .attr(\"x1\", d => d.source.x)",
        "      .attr(\"y1\", d => d.source.y)",
        "      .attr(\"x2\", d => d.target.x)",
        "      .attr(\"y2\", d => d.target.y);",
        "",
        "    node",
        "      .attr(\"transform\", d => `translate(${d.x},${d.y})`);",
        "  }",
        "",
        "  // Add legend",
        "  const legend = svg.append(\"g\")",
        "    .attr(\"transform\", \"translate(20, 20)\")",
        "    .attr(\"font-family\", \"sans-serif\")",
        "    .attr(\"font-size\", 10);",
        "    ",
        "  const legendTitle = legend.append(\"text\")",
        "    .attr(\"x\", 0)",
        "    .attr(\"y\", -10)",
        "    .attr(\"font-weight\", \"bold\")",
        "    .text(\"Node Types\");",
        "    ",
        "  const types = ['creator', 'token', 'suspicious', 'verified'];",
        "  ",
        "  types.forEach((type, i) => {",
        "    const legendRow = legend.append(\"g\")",
        "      .attr(\"transform\", `translate(0, ${i * 20})`);",
        "      ",
        "    legendRow.append(\"rect\")",
        "      .attr(\"width\", 12)",
        "      .attr(\"height\", 12)",
        "      .attr(\"fill\", colorScale(type));",
        "      ",
        "    legendRow.append(\"text\")",
        "      .attr(\"x\", 24)",
        "      .attr(\"y\", 9)",
        "      .attr(\"dy\", \"0.35em\")",
        "      .text(type.charAt(0).toUpperCase() + type.slice(1));",
        "  });",
        "",
        "  // Add instructions",
        "  svg.append(\"text\")",
        "    .attr(\"x\", width - 170)",
        "    .attr(\"y\", height - 20)",
        "    .attr(\"font-family\", \"sans-serif\")",
        "    .attr(\"font-size\", 10)",
        "    .text(\"Drag nodes to reposition, scroll to zoom\");",
        "",
        "  return svg.node();",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "sample-data-cell",
        "language": "javascript"
      },
      "source": [
        "// Sample data",
        "tokenNetworkSampleData = {",
        "  nodes: [",
        "    { id: \"CreatorA\", type: \"creator\", value: 10 },",
        "    { id: \"Token1\", type: \"token\", value: 5, symbol: \"TKN1\" },",
        "    { id: \"Token2\", type: \"token\", value: 8, symbol: \"TKN2\" },",
        "    { id: \"CreatorB\", type: \"creator\", value: 15 },",
        "    { id: \"Token3\", type: \"token\", value: 12, symbol: \"TKN3\" },",
        "    { id: \"SuspiciousX\", type: \"suspicious\", value: 2 },",
        "    { id: \"VerifiedY\", type: \"verified\", value: 20 },",
        "    { id: \"CreatorC\", type: \"creator\", value: 7 },",
        "    { id: \"Token4\", type: \"token\", value: 3, symbol: \"TKN4\" },",
        "    { id: \"Token5\", type: \"token\", value: 9, symbol: \"TKN5\" },",
        "    { id: \"SuspiciousZ\", type: \"suspicious\", value: 4 }",
        "  ],",
        "  links: [",
        "    { source: \"CreatorA\", target: \"Token1\", value: 1 },",
        "    { source: \"CreatorA\", target: \"Token2\", value: 1 },",
        "    { source: \"CreatorB\", target: \"Token2\", value: 1 },",
        "    { source: \"CreatorB\", target: \"Token3\", value: 1 },",
        "    { source: \"CreatorA\", target: \"SuspiciousX\", value: 1 },",
        "    { source: \"VerifiedY\", target: \"Token1\", value: 1 },",
        "    { source: \"VerifiedY\", target: \"Token3\", value: 1 },",
        "    { source: \"CreatorC\", target: \"Token4\", value: 1 },",
        "    { source: \"CreatorC\", target: \"Token5\", value: 1 },",
        "    { source: \"SuspiciousX\", target: \"SuspiciousZ\", value: 1 },",
        "    { source: \"CreatorB\", target: \"CreatorC\", value: 2 },",
        "    { source: \"Token5\", target: \"VerifiedY\", value: 1 }",
        "  ]",
        "}"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "explanation-cell",
        "language": "markdown"
      },
      "source": [
        "## Solana Token Creator Network Visualization",
        "",
        "This interactive network visualization maps relationships between token creators and tokens on the Solana blockchain, highlighting potential connections between legitimate and suspicious entities.",
        "",
        "### Understanding the Visualization:",
        "",
        "- **Node Types**:",
        "  - **Creator**: Wallet addresses that have created tokens",
        "  - **Token**: Individual tokens/mints on Solana",
        "  - **Suspicious**: Entities flagged for suspicious activity",
        "  - **Verified**: Verified entities (exchanges, projects, etc.)",
        "",
        "- **Node Size**: Represents importance or activity level (larger = more important)",
        "",
        "- **Connections**: Lines between nodes show relationships (creation, interaction, etc.)",
        "",
        "### How to Use:",
        "",
        "1. **Filter by Node Type**: Show/hide different types of entities",
        "2. **Adjust Min. Connections**: Filter out nodes with few connections",
        "3. **Interact**: Drag nodes to explore relationships, zoom in/out for detail",
        "",
        "This visualization helps identify potential connections between legitimate and suspicious addresses, revealing patterns that may indicate coordinated activity among token creators."
      ]
    }
  ]
}