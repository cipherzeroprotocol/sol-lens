const notebookData = {
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "title-cell",
        "language": "markdown"
      },
      "source": [
        "# Cross-Chain Bridge Analysis and Money Laundering Detection",
        "",
        "This notebook analyzes cross-chain bridge transactions on Solana to identify potential money laundering patterns and suspicious fund flows."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "imports-cell",
        "language": "javascript"
      },
      "source": [
        "// Import libraries",
        "import {Chart} from \"chart.js\"",
        "import * as d3 from \"d3\"",
        "import { loadVisualizationData } from \"../utils/data-loader.js\"",
        "import { fetchFromCollector, hasCollector } from \"../utils/collector-connector.js\""
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "data-source-cell",
        "language": "javascript"
      },
      "source": [
        "// Main notebook variables",
        "viewof dataSource = Inputs.radio(",
        "  [\"Sample Data\", \"Upload File\", \"Fetch from API\"],",
        "  {value: \"Sample Data\", label: \"Data Source\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "file-upload-cell",
        "language": "javascript"
      },
      "source": [
        "// File upload component",
        "viewof fileUpload = Inputs.file({label: \"Upload JSON file\", accept: \".json\", required: false})"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "data-loading-cell",
        "language": "javascript"
      },
      "source": [
        "// Data loading function based on selected source",
        "data = {",
        "  if (dataSource === \"Sample Data\") {",
        "    return bridgeSampleData;",
        "  } else if (dataSource === \"Upload File\") {",
        "    const fileData = viewof fileUpload.value;",
        "    return fileData ? JSON.parse(await fileData.text()) : bridgeSampleData;",
        "  } else {",
        "    // Use real data from bridge collector",
        "    try {",
        "      if (!hasCollector('bridge')) {",
        "        throw new Error('Bridge collector not available');",
        "      }",
        "      ",
        "      // Show loading indicator",
        "      const loadingMsg = md`**Loading data from blockchain...**  \nThis may take a moment as we analyze cross-chain bridge activity.`;",
        "      yield loadingMsg;",
        "      ",
        "      // Fetch real data from collector - 30 days of bridge activity",
        "      const bridgeData = await fetchFromCollector('bridge', 'analyze_bridge_activity', 30);",
        "      ",
        "      // Use real data if available",
        "      if (bridgeData && bridgeData.high_risk_routes && bridgeData.high_risk_routes.length > 0) {",
        "        return bridgeData;",
        "      }",
        "      ",
        "      // Fallback with informational message",
        "      console.log('No high-risk routes found, using sample data');",
        "      return {",
        "        ...bridgeSampleData,",
        "        _note: 'Using sample data enhanced with any available real data'",
        "      };",
        "    } catch (error) {",
        "      console.error(\"Error loading data from collector:\", error);",
        "      // Return sample data with error information",
        "      return {",
        "        ...bridgeSampleData,",
        "        _error: error.message,",
        "        _note: 'Using sample data due to collector error'",
        "      };",
        "    }",
        "  }",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "date-range-cell",
        "language": "javascript"
      },
      "source": [
        "// Date range filter",
        "viewof dateRange = Inputs.range(",
        "  [new Date(\"2023-01-01\"), new Date(\"2023-10-31\")],",
        "  {value: [new Date(\"2023-07-01\"), new Date(\"2023-10-31\")], ",
        "   step: 86400000, // one day",
        "   label: \"Date Range\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "risk-score-cell",
        "language": "javascript"
      },
      "source": [
        "// Filter for minimum risk score",
        "viewof minRiskScore = Inputs.range(",
        "  [0, 1],",
        "  {value: 0.6, step: 0.05, label: \"Minimum Risk Score\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "bridge-type-cell",
        "language": "javascript"
      },
      "source": [
        "// Bridge type filter",
        "viewof selectedBridges = Inputs.checkbox(",
        "  new Map([",
        "    [\"wormhole\", true],",
        "    [\"allbridge\", true],",
        "    [\"portal\", true],",
        "    [\"sollet\", true]",
        "  ]),",
        "  {label: \"Bridge Types\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "filtered-data-cell",
        "language": "javascript"
      },
      "source": [
        "// Filtered data based on user inputs",
        "filteredRoutes = {",
        "  // Extract high-risk routes data",
        "  if (!data.high_risk_routes) return [];",
        "  ",
        "  const routes = data.high_risk_routes.filter(route => {",
        "    // Apply risk score filter",
        "    if (route.risk_score < minRiskScore) return false;",
        "    ",
        "    // Apply date filter if route has timestamp",
        "    if (route.timestamp) {",
        "      const routeDate = new Date(route.timestamp);",
        "      if (routeDate < dateRange[0] || routeDate > dateRange[1]) return false;",
        "    }",
        "    ",
        "    // Apply bridge filter",
        "    let includeRoute = false;",
        "    for (const bridge of Object.keys(selectedBridges)) {",
        "      if (selectedBridges[bridge] && route.path.includes(bridge)) {",
        "        includeRoute = true;",
        "        break;",
        "      }",
        "    }",
        "    ",
        "    return includeRoute;",
        "  });",
        "  ",
        "  return routes;",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "filtered-summary-cell",
        "language": "javascript"
      },
      "source": [
        "// Filter bridge summary data",
        "filteredBridgeSummary = {",
        "  if (!data.bridge_summary) return {};",
        "  ",
        "  // Filter bridge summary based on selected bridges",
        "  const summary = {};",
        "  ",
        "  for (const [bridge, details] of Object.entries(data.bridge_summary)) {",
        "    if (selectedBridges[bridge]) {",
        "      summary[bridge] = details;",
        "    }",
        "  }",
        "  ",
        "  return summary;",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "summary-cell",
        "language": "javascript"
      },
      "source": [
        "// Summary statistics",
        "summary = {",
        "  if (!filteredRoutes.length) return \"No data matching the filters\";",
        "  ",
        "  const totalVolume = d3.sum(filteredRoutes, d => d.volume_usd);",
        "  const averageRiskScore = d3.mean(filteredRoutes, d => d.risk_score);",
        "  const uniqueAddresses = new Set(filteredRoutes.flatMap(d => d.common_addresses || [])).size;",
        "  ",
        "  // Count transactions across all routes",
        "  const totalTransactions = d3.sum(filteredRoutes, d => d.transaction_count || 0);",
        "  ",
        "  // Count routes by detection criteria",
        "  const criteriaCount = {};",
        "  for (const route of filteredRoutes) {",
        "    if (route.detection_criteria) {",
        "      for (const criterion of route.detection_criteria) {",
        "        criteriaCount[criterion] = (criteriaCount[criterion] || 0) + 1;",
        "      }",
        "    }",
        "  }",
        "  ",
        "  const topCriteria = Object.entries(criteriaCount)",
        "    .sort((a, b) => b[1] - a[1])",
        "    .slice(0, 3)",
        "    .map(([name, count]) => `${name} (${count})`)",
        "    .join(\", \");",
        "  ",
        "  return md`",
        "  ## Cross-Chain Bridge Analysis Summary",
        "  ",
        "  - **High-Risk Routes Identified**: ${filteredRoutes.length}",
        "  - **Total Transaction Volume**: $${totalVolume.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}",
        "  - **Average Risk Score**: ${averageRiskScore.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}",
        "  - **Unique Addresses Involved**: ${uniqueAddresses.toLocaleString()}",
        "  - **Total Transactions**: ${totalTransactions.toLocaleString()}",
        "  - **Top Detection Criteria**: ${topCriteria}",
        "  `;",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "volume-chart-cell",
        "language": "javascript"
      },
      "source": [
        "// Volume by bridge chart",
        "bridgeVolumeChart = {",
        "  // Create dataset from bridge summary",
        "  if (!filteredBridgeSummary || Object.keys(filteredBridgeSummary).length === 0) {",
        "    return md`No bridge data matching the filters`;",
        "  }",
        "  ",
        "  const chartData = Object.entries(filteredBridgeSummary).map(([id, data]) => ({",
        "    id,",
        "    name: data.name,",
        "    volume: data.volume_estimate || 0,",
        "    transactions: data.transaction_count || 0",
        "  }));",
        "  ",
        "  // Sort by volume",
        "  chartData.sort((a, b) => b.volume - a.volume);",
        "  ",
        "  // Create chart",
        "  const width = 800;",
        "  const height = 400;",
        "  const margin = {top: 50, right: 30, bottom: 90, left: 60};",
        "  ",
        "  const svg = d3.create(\"svg\")",
        "    .attr(\"width\", width)",
        "    .attr(\"height\", height);",
        "  ",
        "  const x = d3.scaleBand()",
        "    .domain(chartData.map(d => d.name))",
        "    .range([margin.left, width - margin.right])",
        "    .padding(0.2);",
        "  ",
        "  const y = d3.scaleLinear()",
        "    .domain([0, d3.max(chartData, d => d.volume)])",
        "    .nice()",
        "    .range([height - margin.bottom, margin.top]);",
        "  ",
        "  // Add bars",
        "  svg.append(\"g\")",
        "    .selectAll(\"rect\")",
        "    .data(chartData)",
        "    .join(\"rect\")",
        "      .attr(\"x\", d => x(d.name))",
        "      .attr(\"y\", d => y(d.volume))",
        "      .attr(\"height\", d => y(0) - y(d.volume))",
        "      .attr(\"width\", x.bandwidth())",
        "      .attr(\"fill\", \"steelblue\")",
        "      .append(\"title\")",
        "      .text(d => `${d.name}\\nVolume: $${d.volume.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}\\nTransactions: ${d.transactions.toLocaleString()}`);",
        "  ",
        "  // Add axes",
        "  svg.append(\"g\")",
        "    .attr(\"transform\", `translate(0,${height - margin.bottom})`)",
        "    .call(d3.axisBottom(x))",
        "    .selectAll(\"text\")",
        "      .attr(\"transform\", \"rotate(-45)\")",
        "      .style(\"text-anchor\", \"end\")",
        "      .attr(\"dx\", \"-.8em\")",
        "      .attr(\"dy\", \".15em\");",
        "  ",
        "  svg.append(\"g\")",
        "    .attr(\"transform\", `translate(${margin.left},0)`)",
        "    .call(d3.axisLeft(y).ticks(null, \"s\"));",
        "  ",
        "  // Add title",
        "  svg.append(\"text\")",
        "    .attr(\"x\", width / 2)",
        "    .attr(\"y\", margin.top / 2)",
        "    .attr(\"text-anchor\", \"middle\")",
        "    .attr(\"font-weight\", \"bold\")",
        "    .text(\"Bridge Volume Comparison\");",
        "  ",
        "  // Add Y axis label",
        "  svg.append(\"text\")",
        "    .attr(\"transform\", \"rotate(-90)\")",
        "    .attr(\"y\", margin.left / 3)",
        "    .attr(\"x\", -(height / 2))",
        "    .attr(\"text-anchor\", \"middle\")",
        "    .text(\"Volume (USD)\");",
        "  ",
        "  return svg.node();",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "token-flow-chart-cell",
        "language": "javascript"
      },
      "source": [
        "// Token flow chart",
        "tokenFlowChart = {",
        "  // Check if token flow data exists",
        "  if (!data.token_flows || Object.keys(data.token_flows).length === 0) {",
        "    return md`No token flow data available`;",
        "  }",
        "  ",
        "  // Process token flows into chart format",
        "  const tokens = Object.keys(data.token_flows);",
        "  const directions = new Set();",
        "  const chartData = [];",
        "  ",
        "  for (const token of tokens) {",
        "    const flowData = data.token_flows[token];",
        "    ",
        "    for (const [direction, amount] of Object.entries(flowData)) {",
        "      directions.add(direction);",
        "      chartData.push({",
        "        token,",
        "        direction,",
        "        amount",
        "      });",
        "    }",
        "  }",
        "  ",
        "  const allDirections = [...directions].sort();",
        "  ",
        "  // Create grouped bar chart",
        "  const width = 1000;",
        "  const height = 500;",
        "  const margin = {top: 50, right: 200, bottom: 90, left: 80};",
        "  ",
        "  const svg = d3.create(\"svg\")",
        "    .attr(\"width\", width)",
        "    .attr(\"height\", height);",
        "  ",
        "  // Group data by token",
        "  const groupedData = d3.group(chartData, d => d.token);",
        "  ",
        "  // X scale for tokens",
        "  const x0 = d3.scaleBand()",
        "    .domain(tokens)",
        "    .range([margin.left, width - margin.right])",
        "    .paddingOuter(0.1)",
        "    .paddingInner(0.1);",
        "  ",
        "  // X scale for directions within each token",
        "  const x1 = d3.scaleBand()",
        "    .domain(allDirections)",
        "    .rangeRound([0, x0.bandwidth()])",
        "    .padding(0.05);",
        "  ",
        "  // Y scale for amounts",
        "  const y = d3.scaleLinear()",
        "    .domain([0, d3.max(chartData, d => d.amount)])",
        "    .nice()",
        "    .range([height - margin.bottom, margin.top]);",
        "  ",
        "  // Color scale for directions",
        "  const color = d3.scaleOrdinal()",
        "    .domain(allDirections)",
        "    .range(d3.schemeCategory10);",
        "  ",
        "  // Add bars",
        "  svg.append(\"g\")",
        "    .selectAll(\"g\")",
        "    .data(groupedData)",
        "    .join(\"g\")",
        "      .attr(\"transform\", ([token]) => `translate(${x0(token)},0)`)",
        "    .selectAll(\"rect\")",
        "    .data(([_, values]) => values)",
        "    .join(\"rect\")",
        "      .attr(\"x\", d => x1(d.direction))",
        "      .attr(\"y\", d => y(d.amount))",
        "      .attr(\"width\", x1.bandwidth())",
        "      .attr(\"height\", d => y(0) - y(d.amount))",
        "      .attr(\"fill\", d => color(d.direction))",
        "      .append(\"title\")",
        "      .text(d => `${d.token} (${d.direction})\\nVolume: $${d.amount.toLocaleString()}`);",
        "  ",
        "  // Add X axis",
        "  svg.append(\"g\")",
        "    .attr(\"transform\", `translate(0,${height - margin.bottom})`)",
        "    .call(d3.axisBottom(x0).tickSizeOuter(0))",
        "    .selectAll(\"text\")",
        "      .style(\"text-anchor\", \"middle\")",
        "      .attr(\"font-weight\", \"bold\");",
        "  ",
        "  // Add Y axis",
        "  svg.append(\"g\")",
        "    .attr(\"transform\", `translate(${margin.left},0)`)",
        "    .call(d3.axisLeft(y).ticks(null, \"s\"));",
        "  ",
        "  // Add title",
        "  svg.append(\"text\")",
        "    .attr(\"x\", width / 2)",
        "    .attr(\"y\", margin.top / 2)",
        "    .attr(\"text-anchor\", \"middle\")",
        "    .attr(\"font-size\", \"16px\")",
        "    .attr(\"font-weight\", \"bold\")",
        "    .text(\"Token Flow Across Bridges\");",
        "  ",
        "  // Add Y axis label",
        "  svg.append(\"text\")",
        "    .attr(\"transform\", \"rotate(-90)\")",
        "    .attr(\"y\", margin.left / 3)",
        "    .attr(\"x\", -(height / 2))",
        "    .attr(\"text-anchor\", \"middle\")",
        "    .text(\"Volume (USD)\");",
        "  ",
        "  // Add legend",
        "  const legend = svg.append(\"g\")",
        "    .attr(\"font-family\", \"sans-serif\")",
        "    .attr(\"font-size\", 10)",
        "    .attr(\"text-anchor\", \"start\")",
        "    .selectAll(\"g\")",
        "    .data(allDirections)",
        "    .join(\"g\")",
        "      .attr(\"transform\", (d, i) => `translate(${width - margin.right + 20},${margin.top + i * 20})`);",
        "  ",
        "  legend.append(\"rect\")",
        "    .attr(\"x\", 0)",
        "    .attr(\"width\", 19)",
        "    .attr(\"height\", 19)",
        "    .attr(\"fill\", color);",
        "  ",
        "  legend.append(\"text\")",
        "    .attr(\"x\", 24)",
        "    .attr(\"y\", 9.5)",
        "    .attr(\"dy\", \"0.32em\")",
        "    .text(d => d);",
        "  ",
        "  return svg.node();",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "route-sankey-cell",
        "language": "javascript"
      },
      "source": [
        "// Sankey diagram of cross-chain routes",
        "routeSankeyDiagram = {",
        "  if (!filteredRoutes.length) return md`No route data matching the filters`;",
        "  ",
        "  // Process routes for Sankey diagram",
        "  const nodes = new Set();",
        "  const links = [];",
        "  ",
        "  // Collect all nodes and links from paths",
        "  filteredRoutes.forEach(route => {",
        "    const path = route.path;",
        "    if (!path || path.length < 2) return;",
        "    ",
        "    // Add all nodes in the path",
        "    path.forEach(node => nodes.add(node));",
        "    ",
        "    // Create links between consecutive nodes",
        "    for (let i = 0; i < path.length - 1; i++) {",
        "      const source = path[i];",
        "      const target = path[i + 1];",
        "      const existingLink = links.find(l => l.source === source && l.target === target);",
        "      ",
        "      if (existingLink) {",
        "        existingLink.value += route.volume_usd || 1000; // Default if no volume",
        "        existingLink.count += 1;",
        "      } else {",
        "        links.push({",
        "          source,",
        "          target,",
        "          value: route.volume_usd || 1000, // Default if no volume",
        "          count: 1",
        "        });",
        "      }",
        "    }",
        "  });",
        "  ",
        "  // Convert to arrays for d3-sankey",
        "  const nodeList = Array.from(nodes).map(id => ({ id }));",
        "  const nodeMap = new Map(nodeList.map((node, i) => [node.id, i]));",
        "  ",
        "  // Map source/target names to indices",
        "  const linkList = links.map(link => ({",
        "    source: nodeMap.get(link.source),",
        "    target: nodeMap.get(link.target),",
        "    value: link.value,",
        "    count: link.count",
        "  }));",
        "  ",
        "  // Create Sankey diagram",
        "  const width = 900;",
        "  const height = 500;",
        "  const margin = {top: 10, right: 10, bottom: 10, left: 10};",
        "  ",
        "  const svg = d3.create(\"svg\")",
        "    .attr(\"width\", width)",
        "    .attr(\"height\", height);",
        "  ",
        "  // Create Sankey generator",
        "  const sankey = d3.sankey()",
        "    .nodeId(d => d.id)",
        "    .nodeWidth(15)",
        "    .nodePadding(10)",
        "    .extent([[margin.left, margin.top], [width - margin.right, height - margin.bottom]]);",
        "  ",
        "  // Generate the Sankey data",
        "  const { nodes: sankeyNodes, links: sankeyLinks } = sankey({",
        "    nodes: nodeList.map(d => Object.assign({}, d)),",
        "    links: linkList",
        "  });",
        "  ",
        "  // Create color scale for nodes",
        "  const color = d3.scaleOrdinal(d3.schemeCategory10);",
        "  ",
        "  // Draw the links",
        "  const link = svg.append(\"g\")",
        "    .selectAll(\".link\")",
        "    .data(sankeyLinks)",
        "    .join(\"path\")",
        "      .attr(\"class\", \"link\")",
        "      .attr(\"d\", d3.sankeyLinkHorizontal())",
        "      .attr(\"fill\", \"none\")",
        "      .attr(\"stroke\", d => d3.color(color(d.source.id)).darker())",
        "      .attr(\"stroke-width\", d => Math.max(1, d.width))",
        "      .attr(\"stroke-opacity\", 0.5)",
        "      .append(\"title\")",
        "      .text(d => `${d.source.id} → ${d.target.id}\\nVolume: $${d.value.toLocaleString()}\\nTransactions: ${d.count}`);",
        "  ",
        "  // Draw the nodes",
        "  const node = svg.append(\"g\")",
        "    .selectAll(\".node\")",
        "    .data(sankeyNodes)",
        "    .join(\"g\")",
        "      .attr(\"class\", \"node\")",
        "      .attr(\"transform\", d => `translate(${d.x0},${d.y0})`);",
        "  ",
        "  node.append(\"rect\")",
        "    .attr(\"height\", d => d.y1 - d.y0)",
        "    .attr(\"width\", d => d.x1 - d.x0)",
        "    .attr(\"fill\", d => color(d.id))",
        "    .attr(\"stroke\", d => d3.color(color(d.id)).darker())",
        "    .append(\"title\")",
        "    .text(d => `${d.id}\\nVolume: $${d.value.toLocaleString()}`);",
        "  ",
        "  // Add node labels",
        "  node.append(\"text\")",
        "    .attr(\"x\", d => d.x0 < width / 2 ? 6 + (d.x1 - d.x0) : -6)",
        "    .attr(\"y\", d => (d.y1 - d.y0) / 2)",
        "    .attr(\"dy\", \"0.35em\")",
        "    .attr(\"text-anchor\", d => d.x0 < width / 2 ? \"start\" : \"end\")",
        "    .text(d => d.id)",
        "    .attr(\"font-size\", \"10px\");",
        "  ",
        "  // Add title",
        "  svg.append(\"text\")",
        "    .attr(\"x\", width / 2)",
        "    .attr(\"y\", margin.top * 2)",
        "    .attr(\"text-anchor\", \"middle\")",
        "    .attr(\"font-size\", \"16px\")",
        "    .attr(\"font-weight\", \"bold\")",
        "    .text(\"Cross-Chain Money Flow Routes\");",
        "  ",
        "  return svg.node();",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "risk-score-chart-cell",
        "language": "javascript"
      },
      "source": [
        "// Risk score distribution chart",
        "riskScoreChart = {",
        "  if (!filteredRoutes.length) return md`No route data matching the filters`;",
        "  ",
        "  // Create histogram data",
        "  const binCount = 10;",
        "  const bins = d3.histogram()",
        "    .domain([0, 1])",
        "    .thresholds(d3.range(0, 1.01, 1/binCount))",
        "    .value(d => d.risk_score)(filteredRoutes);",
        "  ",
        "  // Chart dimensions",
        "  const width = 700;",
        "  const height = 400;",
        "  const margin = {top: 40, right: 20, bottom: 40, left: 40};",
        "  ",
        "  const svg = d3.create(\"svg\")",
        "    .attr(\"width\", width)",
        "    .attr(\"height\", height);",
        "  ",
        "  // X scale (risk score)",
        "  const x = d3.scaleLinear()",
        "    .domain([0, 1])",
        "    .range([margin.left, width - margin.right]);",
        "  ",
        "  // Y scale (count)",
        "  const y = d3.scaleLinear()",
        "    .domain([0, d3.max(bins, d => d.length)])",
        "    .nice()",
        "    .range([height - margin.bottom, margin.top]);",
        "  ",
        "  // Color scale based on risk score",
        "  const color = d3.scaleSequential()",
        "    .domain([0, 1])",
        "    .interpolator(d3.interpolateRgb(\"#2ca02c\", \"#d62728\"));",
        "  ",
        "  // Draw bars",
        "  svg.append(\"g\")",
        "    .selectAll(\"rect\")",
        "    .data(bins)",
        "    .join(\"rect\")",
        "      .attr(\"x\", d => x(d.x0) + 1)",
        "      .attr(\"y\", d => y(d.length))",
        "      .attr(\"width\", d => Math.max(0, x(d.x1) - x(d.x0) - 2))",
        "      .attr(\"height\", d => y(0) - y(d.length))",
        "      .attr(\"fill\", d => color((d.x0 + d.x1) / 2))",
        "      .append(\"title\")",
        "      .text(d => `Risk Score: ${d.x0.toFixed(2)}-${d.x1.toFixed(2)}\\nCount: ${d.length}`);",
        "  ",
        "  // Add X axis",
        "  svg.append(\"g\")",
        "    .attr(\"transform\", `translate(0,${height - margin.bottom})`)",
        "    .call(d3.axisBottom(x)",
        "      .ticks(binCount)",
        "      .tickFormat(d => d.toFixed(1)))",
        "    .call(g => g.append(\"text\")",
        "      .attr(\"x\", width - margin.right)",
        "      .attr(\"y\", 30)",
        "      .attr(\"fill\", \"#000\")",
        "      .attr(\"text-anchor\", \"end\")",
        "      .text(\"Risk Score\"));",
        "  ",
        "  // Add Y axis",
        "  svg.append(\"g\")",
        "    .attr(\"transform\", `translate(${margin.left},0)`)",
        "    .call(d3.axisLeft(y))",
        "    .call(g => g.append(\"text\")",
        "      .attr(\"x\", -margin.left)",
        "      .attr(\"y\", 10)",
        "      .attr(\"fill\", \"#000\")",
        "      .attr(\"text-anchor\", \"start\")",
        "      .text(\"Count\"));",
        "  ",
        "  // Add title",
        "  svg.append(\"text\")",
        "    .attr(\"x\", width / 2)",
        "    .attr(\"y\", margin.top / 2)",
        "    .attr(\"text-anchor\", \"middle\")",
        "    .attr(\"font-weight\", \"bold\")",
        "    .text(\"Distribution of Risk Scores\");",
        "  ",
        "  return svg.node();",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "data-table-cell",
        "language": "javascript"
      },
      "source": [
        "// Data table of high risk routes",
        "viewof routesTable = Inputs.table(filteredRoutes, {",
        "  columns: [",
        "    \"route_id\",",
        "    \"path\",",
        "    \"risk_score\",",
        "    \"volume_usd\",",
        "    \"transaction_count\",",
        "    \"detection_criteria\"",
        "  ],",
        "  width: {",
        "    path: 250,",
        "    detection_criteria: 200",
        "  },",
        "  format: {",
        "    risk_score: x => x.toFixed(2),",
        "    volume_usd: x => `$${x.toLocaleString()}`,",
        "    path: x => x.join(' → ')",
        "  },",
        "  sort: \"risk_score\",",
        "  reverse: true",
        "})"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "methodology-cell",
        "language": "markdown"
      },
      "source": [
        "## Cross-Chain Bridge Analysis Methodology",
        "",
        "This notebook analyzes cross-chain bridge transactions to identify potential money laundering patterns. Cross-chain bridges are frequently used in money laundering operations to obscure the source of funds.",
        "",
        "**Methodology:**",
        "",
        "1. **Data Collection**: We collect transaction data from major Solana cross-chain bridges including Wormhole, Portal, Allbridge, and others.",
        "",
        "2. **Pattern Detection**: We identify suspicious patterns including:",
        "   - **Amount Splitting**: Funds split into multiple smaller transactions before bridging",
        "   - **Rapid Bridging**: Funds quickly moved to another chain after receiving",
        "   - **Multiple Hops**: Funds moved across three or more chains in short time",
        "   - **Round Amounts**: Perfectly round amounts (e.g., exactly 10 ETH, 100 SOL)",
        "   - **Sanctioned Chain Routes**: Routes that include chains with weak AML enforcement",
        "",
        "3. **Risk Scoring**: Each route is assigned a risk score based on detected patterns, transaction amounts, and address history.",
        "",
        "4. **Route Analysis**: We map the flow of funds across chains to identify complex laundering patterns.",
        "",
        "This analysis helps identify potential money laundering operations that use cross-chain bridges to obscure the source of funds or evade sanctions."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "sample-data-cell",
        "language": "javascript"
      },
      "source": [
        "// Sample data for testing",
        "bridgeSampleData = {",
        "  \"bridge_summary\": {",
        "    \"wormhole\": {",
        "      \"name\": \"Wormhole Bridge\",",
        "      \"transaction_count\": 2476,",
        "      \"volume_estimate\": 15486321.75,",
        "      \"supported_chains\": [\"ethereum\", \"bsc\", \"polygon\", \"avalanche\", \"arbitrum\", \"optimism\"],",
        "      \"most_active_chains\": [\"ethereum\", \"bsc\"]",
        "    },",
        "    \"allbridge\": {",
        "      \"name\": \"Allbridge\",",
        "      \"transaction_count\": 1253,",
        "      \"volume_estimate\": 8965432.50,",
        "      \"supported_chains\": [\"ethereum\", \"bsc\", \"polygon\", \"avalanche\", \"tron\"],",
        "      \"most_active_chains\": [\"bsc\", \"tron\"]",
        "    },",
        "    \"portal\": {",
        "      \"name\": \"Portal (Wormhole)\",",
        "      \"transaction_count\": 945,",
        "      \"volume_estimate\": 6342800.25,",
        "      \"supported_chains\": [\"ethereum\", \"bsc\", \"polygon\", \"avalanche\"],",
        "      \"most_active_chains\": [\"ethereum\", \"polygon\"]",
        "    },",
        "    \"sollet\": {",
        "      \"name\": \"Sollet Bridge\",",
        "      \"transaction_count\": 532,",
        "      \"volume_estimate\": 2145678.90,",
        "      \"supported_chains\": [\"ethereum\"],",
        "      \"most_active_chains\": [\"ethereum\"]",
        "    }",
        "  },",
        "  \"high_risk_routes\": [",
        "    {",
        "      \"route_id\": \"route-1\",",
        "      \"path\": [\"solana\", \"ethereum\", \"bsc\", \"tron\"],",
        "      \"risk_score\": 0.92,",
        "      \"volume_usd\": 1500000,",
        "      \"transaction_count\": 37,",
        "      \"common_addresses\": [",
        "        \"9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin\",",
        "        \"0x1234567890123456789012345678901234567890\"",
        "      ],",
        "      \"detection_criteria\": [\"multiple_hops\", \"sanctioned_chain_route\"]",
        "    },",
        "    {",
        "      \"route_id\": \"route-2\",",
        "      \"path\": [\"solana\", \"ethereum\", \"arbitrum\", \"optimism\"],",
        "      \"risk_score\": 0.75,",
        "      \"volume_usd\": 870000,",
        "      \"transaction_count\": 24,",
        "      \"common_addresses\": [",
        "        \"VinesRG7K3ubzKLbxXz197c1RHV3cACkvGr9Zca7BSw\",",
        "        \"0xabcdef1234567890abcdef1234567890abcdef12\"",
        "      ],",
        "      \"detection_criteria\": [\"rapid_bridging\", \"amount_splitting\"]",
        "    },",
        "    {",
        "      \"route_id\": \"route-3\",",
        "      \"path\": [\"solana\", \"bsc\", \"tron\"],",
        "      \"risk_score\": 0.88,",
        "      \"volume_usd\": 1250000,",
        "      \"transaction_count\": 31,",
        "      \"common_addresses\": [",
        "        \"tor1xzb2Zyy1cUxXmyJfR8aNXuWnwHG8AwgaG7UGD4K\",",
        "        \"0x9876543210987654321098765432109876543210\"",
        "      ],",
        "      \"detection_criteria\": [\"sanctioned_chain_route\", \"round_amounts\"]",
        "    },",
        "    {",
        "      \"route_id\": \"route-4\",",
        "      \"path\": [\"solana\", \"ethereum\", \"polygon\"],",
        "      \"risk_score\": 0.65,",
        "      \"volume_usd\": 550000,",
        "      \"transaction_count\": 19,",
        "      \"common_addresses\": [",
        "        \"SoLWhaLEsP3UUt4HhkGCNeHZ7hH3cmTDDDi1BKLx523\",",
        "        \"0xfedcba9876543210fedcba9876543210fedcba98\"",
        "      ],",
        "      \"detection_criteria\": [\"rapid_bridging\"]",
        "    },",
        "    {",
        "      \"route_id\": \"route-5\",",
        "      \"path\": [\"solana\", \"ethereum\", \"avalanche\", \"bsc\", \"tron\"],",
        "      \"risk_score\": 0.95,",
        "      \"volume_usd\": 2100000,",
        "      \"transaction_count\": 45,",
        "      \"common_addresses\": [",
        "        \"5MixPN8YxgnYBq5CwC22TwxRkPfgGGxDRvLJHbF2XBQj\",",
        "        \"0x0123456789abcdef0123456789abcdef01234567\"",
        "      ],",
        "      \"detection_criteria\": [\"multiple_hops\", \"sanctioned_chain_route\", \"amount_splitting\"]",
        "    },",
        "    {",
        "      \"route_id\": \"route-6\",",
        "      \"path\": [\"solana\", \"bsc\", \"ethereum\"],",
        "      \"risk_score\": 0.72,",
        "      \"volume_usd\": 720000,",
        "      \"transaction_count\": 22,",
        "      \"common_addresses\": [",
        "        \"BLend1yWcTN1iEZZ4v4yG4yZL25c4A1yTz7brhPg37jT\",",
        "        \"0x76543210fedcba9876543210fedcba9876543210\"",
        "      ],",
        "      \"detection_criteria\": [\"round_amounts\"]",
        "    },",
        "    {",
        "      \"route_id\": \"route-7\",",
        "      \"path\": [\"solana\", \"ethereum\"],",
        "      \"risk_score\": 0.55,",
        "      \"volume_usd\": 350000,",
        "      \"transaction_count\": 14,",
        "      \"common_addresses\": [",
        "        \"Nfts4UjubHod2ngwUJKSXSGDDXS5oCSeRRwD7SWJ2YnL\",",
        "        \"0xabcdef0123456789abcdef0123456789abcdef01\"",
        "      ],",
        "      \"detection_criteria\": [\"rapid_bridging\"]",
        "    },",
        "    {",
        "      \"route_id\": \"route-8\",",
        "      \"path\": [\"solana\", \"avalanche\", \"polygon\", \"ethereum\", \"arbitrum\"],",
        "      \"risk_score\": 0.85,",
        "      \"volume_usd\": 1850000,",
        "      \"transaction_count\": 41,",
        "      \"common_addresses\": [",
        "        \"Dex5UcgzuGK2c2dU8QZnFZxTXh8nx4EU2Mupsfnisg8L\",",
        "        \"0x210fedcba9876543210fedcba9876543210fedc\"",
        "      ],",
        "      \"detection_criteria\": [\"multiple_hops\", \"amount_splitting\"]",
        "    }",
        "  ],",
        "  \"token_flows\": {",
        "    \"USDC\": {",
        "      \"solana_to_ethereum\": 35000000,",
        "      \"ethereum_to_solana\": 28000000,",
        "      \"solana_to_bsc\": 12000000,",
        "      \"bsc_to_solana\": 9000000",
        "    },",
        "    \"USDT\": {",
        "      \"solana_to_ethereum\": 42000000,",
        "      \"ethereum_to_solana\": 31000000,",
        "      \"solana_to_bsc\": 15000000,",
        "      \"bsc_to_solana\": 11000000",
        "    },",
        "    \"SOL\": {",
        "      \"solana_to_ethereum\": 8500000,",
        "      \"ethereum_to_solana\": 7200000",
        "    },",
        "    \"WBTC\": {",
        "      \"solana_to_ethereum\": 18500000,",
        "      \"ethereum_to_solana\": 15300000,",
        "      \"solana_to_bsc\": 4200000,",
        "      \"bsc_to_solana\": 3800000",
        "    },",
        "    \"ETH\": {",
        "      \"solana_to_ethereum\": 22000000,",
        "      \"ethereum_to_solana\": 19500000",
        "    }",
        "  }",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "export-format-cell",
        "language": "javascript"
      },
      "source": [
        "// Export functionality",
        "viewof exportFormat = Inputs.radio(",
        "  [\"JSON\", \"CSV\", \"PNG\"],",
        "  {value: \"JSON\", label: \"Export Format\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "export-button-cell",
        "language": "javascript"
      },
      "source": [
        "viewof exportButton = Inputs.button(\"Export Data\")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "export-data-cell",
        "language": "javascript"
      },
      "source": [
        "// Export handling",
        "exportData = {",
        "  if (viewof exportButton.value) {",
        "    if (exportFormat === \"JSON\") {",
        "      const dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(filteredRoutes));",
        "      const downloadLink = document.createElement(\"a\");",
        "      downloadLink.setAttribute(\"href\", dataStr);",
        "      downloadLink.setAttribute(\"download\", \"bridge_analysis.json\");",
        "      downloadLink.click();",
        "      return \"Data exported as JSON\";",
        "    } else if (exportFormat === \"CSV\") {",
        "      let csvContent = \"data:text/csv;charset=utf-8,\";",
        "      ",
        "      // Add header",
        "      const headers = [\"route_id\", \"path\", \"risk_score\", \"volume_usd\", \"transaction_count\", \"detection_criteria\"];",
        "      csvContent += headers.join(\",\") + \"\\r\\n\";",
        "      ",
        "      // Add rows",
        "      filteredRoutes.forEach(row => {",
        "        const values = headers.map(header => {",
        "          const value = row[header];",
        "          if (header === \"path\") return `\"${value.join(' → ')}\"`; ",
        "          if (header === \"detection_criteria\") return `\"${value.join(', ')}\"`; ",
        "          return typeof value === 'string' ? `\"${value}\"` : value;",
        "        });",
        "        csvContent += values.join(\",\") + \"\\r\\n\";",
        "      });",
        "      ",
        "      const encodedUri = encodeURI(csvContent);",
        "      const downloadLink = document.createElement(\"a\");",
        "      downloadLink.setAttribute(\"href\", encodedUri);",
        "      downloadLink.setAttribute(\"download\", \"bridge_analysis.csv\");",
        "      downloadLink.click();",
        "      return \"Data exported as CSV\";",
        "    } else if (exportFormat === \"PNG\") {",
        "      // This would be implemented with additional libraries in a real environment",
        "      return \"PNG export not implemented in this example\";",
        "    }",
        "  }",
        "  return \"\";",
        "}"
      ]
    }
  ]
}
