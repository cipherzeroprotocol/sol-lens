const notebookData = {
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "title-cell",
        "language": "markdown"
      },
      "source": [
        "# Sandwich Attack Visualization for Solana DEXs",
        "",
        "This notebook visualizes sandwich attacks on Solana decentralized exchanges, showing patterns, profits, and affected token pairs."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "imports-cell",
        "language": "javascript"
      },
      "source": [
        "// Import libraries",
        "import {Chart} from \"chart.js\"",
        "import * as d3 from \"d3\"",
        "import { fetchFromCollector, hasCollector } from \"../utils/collector-connector.js\""
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "data-source-cell",
        "language": "javascript"
      },
      "source": [
        "// Main notebook variables",
        "viewof dataSource = Inputs.radio(",
        "  [\"Sample Data\", \"Upload File\"], // Removed \"Fetch from API\" for simplicity",
        "  {value: \"Sample Data\", label: \"Data Source\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "file-upload-cell",
        "language": "javascript"
      },
      "source": [
        "// File upload component - make it required if \"Upload File\" is selected",
        "viewof fileUpload = Inputs.file({",
        "  label: \"Upload sandwich_attacks.json\",",
        "  accept: \".json\",",
        "  required: dataSource === \"Upload File\" // Make required based on selection",
        "})"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "data-loading-cell",
        "language": "javascript"
      },
      "source": [
        "// Data loading function based on selected source",
        "data = (async () => { // Wrap in async function for await",
        "  if (dataSource === \"Sample Data\") {",
        "    return sandwichSampleData; // Use existing sample data",
        "  } else if (dataSource === \"Upload File\") {",
        "    // Ensure fileUpload is defined and has a value before accessing it",
        "    const file = fileUpload; // Directly use the viewof value",
        "    if (!file) {",
        "      return []; // Return empty array if no file is uploaded yet",
        "    }",
        "    try {",
        "      // Read the file content as text and parse as JSON",
        "      const fileContent = await file.text();",
        "      const jsonData = JSON.parse(fileContent);",
        "      // Basic validation: check if it's an array",
        "      if (!Array.isArray(jsonData)) {",
        "        throw new Error(\"Uploaded file is not a valid JSON array.\");",
        "      }",
        "      // Optional: Validate structure of the first item if needed",
        "      if (jsonData.length > 0 && typeof jsonData[0].profit_sol === 'undefined') {",
        "         console.warn(\"Warning: Uploaded data might not have the expected structure (e.g., missing 'profit_sol').\");",
        "      }",
        "      return jsonData;",
        "    } catch (error) {",
        "      console.error(\"Error parsing uploaded JSON file:\", error);",
        "      throw new Error(`Failed to parse uploaded file: ${error.message}. Please ensure it's valid JSON.`);",
        "    }",
        "  } else { // Fetch from API",
        "    try {",
        "      if (!hasCollector('sandwich')) {",
        "        throw new Error('Sandwich attack collector not available');",
        "      }",
        "      ",
        "      // Show loading message",
        "      const loadingMsg = md`**Loading sandwich attack data from blockchain...**  \nThis may take a moment as we analyze DEX trading patterns.`;",
        "      yield loadingMsg;",
        "      ",
        "      // Fetch real data from collector - 14 days of sandwich attacks",
        "      const sandwichData = await fetchFromCollector('sandwich', 'detect_sandwich_attacks', 14);",
        "      ",
        "      // Use real data if available",
        "      if (sandwichData && sandwichData.length > 0) {",
        "        return sandwichData;",
        "      }",
        "      ",
        "      // Fallback to sample data with note",
        "      console.log('No sandwich attacks found, using sample data');",
        "      return sandwichSampleData.map(item => ({",
        "        ...item,",
        "        _note: 'Sample data (real data unavailable)'",
        "      }));",
        "    } catch (error) {",
        "      console.error(\"Error loading sandwich attack data:\", error);",
        "      // Return sample data with error information",
        "      return sandwichSampleData.map(item => ({",
        "        ...item,",
        "        _error: error.message,",
        "        _note: 'Sample data due to collector error'",
        "      }));",
        "    }",
        "  }",
        "})()"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "date-range-cell",
        "language": "javascript"
      },
      "source": [
        "// Date range filter",
        "viewof dateRange = Inputs.range(",
        "  // Adjust default range based on potential data range or make it wider",
        "  [new Date(\"2023-01-01\"), new Date()], // Default from 2023 to now",
        "  {",
        "    // Set initial value based on data extent if possible, otherwise default",
        "    value: data && data.length > 0 // Check if data is loaded and not empty",
        "           ? [d3.min(data, d => new Date(d.timestamp)), d3.max(data, d => new Date(d.timestamp))]",
        "           : [new Date(new Date().getFullYear(), 0, 1), new Date()], // Default to current year if no data",
        "    step: 86400000, // one day",
        "    label: \"Date Range\"",
        "  }",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "min-profit-cell",
        "language": "javascript"
      },
      "source": [
        "// Filter for minimum profit threshold",
        "viewof minProfit = Inputs.range(",
        "  [0, 5],",
        "  {value: 0.1, step: 0.1, label: \"Minimum Profit (SOL)\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "dex-selection-cell",
        "language": "javascript"
      },
      "source": [
        "// Filter for DEX selection",
        "viewof selectedDEX = Inputs.select(",
        "  [\"All\", \"Jupiter\", \"Raydium\", \"Orca\", \"Serum\", \"Saber\"],",
        "  {value: \"All\", label: \"DEX\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "pair-selection-cell",
        "language": "javascript"
      },
      "source": [
        "// Filter for token pair",
        "viewof selectedPair = Inputs.select(",
        "  [\"All\", \"SOL/USDC\", \"SOL/USDT\", \"BTC/USDC\", \"ETH/USDC\", \"BONK/SOL\", \"SAMO/USDC\"],",
        "  {value: \"All\", label: \"Token Pair\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "filtered-data-cell",
        "language": "javascript"
      },
      "source": [
        "// Filtered data based on user inputs",
        "filteredData = {",
        "  // Add a check for data readiness",
        "  if (!data || !Array.isArray(data) || data.length === 0) { // Ensure data is a non-empty array",
        "    return []; // Return empty if data is not loaded or empty",
        "  }",
        "",
        "  const startDate = dateRange[0];",
        "  const endDate = dateRange[1];",
        "",
        "  return data.filter(d => {",
        "    // Add checks for valid data points",
        "    if (!d || !d.timestamp || typeof d.profit_sol === 'undefined') {",
        "      console.warn(\"Skipping invalid data point:\", d);",
        "      return false;",
        "    }",
        "    const date = new Date(d.timestamp);",
        "    // Check if date is valid",
        "    if (isNaN(date.getTime())) {",
        "        console.warn(\"Skipping data point with invalid date:\", d);",
        "        return false;",
        "    }",
        "    const dexMatch = selectedDEX === \"All\" || d.dex === selectedDEX;",
        "    const pairMatch = selectedPair === \"All\" || d.token_pair === selectedPair;",
        "    return date >= startDate &&",
        "           date <= endDate &&",
        "           d.profit_sol >= minProfit &&",
        "           dexMatch &&",
        "           pairMatch;",
        "  });",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "summary-cell",
        "language": "javascript"
      },
      "source": [
        "// Summary statistics",
        "summary = {",
        "  // Check filteredData readiness",
        "  if (!filteredData || !filteredData.length) return md`## Sandwich Attack Summary\\n\\nNo data matching the filters.`;",
        "",
        "  const totalSandwiches = filteredData.length;",
        "  // Ensure profit_sol exists and is a number before summing",
        "  const totalProfit = d3.sum(filteredData, d => +d.profit_sol || 0);",
        "  const avgProfit = totalSandwiches > 0 ? totalProfit / totalSandwiches : 0;",
        "  const maxProfit = d3.max(filteredData, d => +d.profit_sol || 0);",
        "  const uniqueAttackers = new Set(filteredData.map(d => d.attacker_address)).size;",
        "  // Assuming one victim per sandwich record",
        "  const victimsCount = totalSandwiches;",
        "  // Estimate USD profit (use a placeholder rate or fetch dynamically if possible)",
        "  const solPriceUSD = 60; // Placeholder SOL price",
        "",
        "  return md`",
        "  ## Sandwich Attack Summary",
        "",
        "  - **Total Sandwich Attacks**: ${totalSandwiches.toLocaleString()}",
        "  - **Total Profit Extracted**: ${totalProfit.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} SOL ($${(totalProfit * solPriceUSD).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}})",
        "  - **Average Profit Per Attack**: ${avgProfit.toFixed(4)} SOL",
        "  - **Largest Profit**: ${maxProfit.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} SOL",
        "  - **Unique Attackers**: ${uniqueAttackers}",
        "  - **Victims Affected**: ${victimsCount}",
        "  `;",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "time-chart-cell",
        "language": "javascript"
      },
      "source": [
        "// Time series chart of sandwich attacks",
        "sandwichTimeChart = {",
        "  // Check filteredData readiness",
        "  if (!filteredData || !filteredData.length) return html`<p>No data available for time series chart.</p>`;",
        "",
        "  // Group by day and sum values",
        "  const timeData = d3.rollup(",
        "    filteredData,",
        "    v => ({",
        "      count: v.length,",
        "      profit: d3.sum(v, d => +d.profit_sol || 0) // Ensure numeric sum",
        "    }),",
        "    d => d3.timeDay(new Date(d.timestamp)) // Ensure date parsing",
        "  );",
        "",
        "  // Convert to array for charting",
        "  const chartData = Array.from(timeData, ([date, data]) => ({",
        "    date,",
        "    count: data.count,",
        "    profit: data.profit",
        "  })).sort((a, b) => a.date - b.date);",
        "",
        "  // Check if chartData has valid entries",
        "  if (!chartData || chartData.length === 0) return html`<p>No valid time data to plot.</p>`;",
        "",
        "  // Ensure scales handle potential empty domains gracefully",
        "  const xDomain = d3.extent(chartData, d => d.date);",
        "  const y1Max = d3.max(chartData, d => d.count);",
        "  const y2Max = d3.max(chartData, d => d.profit);",
        "",
        "  if (!xDomain[0] || !xDomain[1] || y1Max === undefined || y2Max === undefined) {",
        "      return html`<p>Insufficient data to determine chart scales.</p>`;",
        "  }",
        "",
        "  const width = 800; // Use Observable's width variable if preferred",
        "  const height = 400;",
        "  const margin = {top: 40, right: 60, bottom: 30, left: 50}; // Adjusted margins",
        "",
        "  const svg = d3.create(\"svg\")",
        "      .attr(\"viewBox\", [0, 0, width, height]) // Use viewBox for responsiveness",
        "      .attr(\"width\", width) // Set explicit width/height for initial render",
        "      .attr(\"height\", height)",
        "      .style(\"max-width\", \"100%\") // Allow shrinking",
        "      .style(\"height\", \"auto\"); // Adjust height automatically",
        "",
        "  const x = d3.scaleTime()",
        "      .domain(xDomain)",
        "      .range([margin.left, width - margin.right]);",
        "",
        "  const y1 = d3.scaleLinear()",
        "      .domain([0, y1Max]).nice()",
        "      .range([height - margin.bottom, margin.top]);",
        "",
        "  const y2 = d3.scaleLinear()",
        "      .domain([0, y2Max]).nice()",
        "      .range([height - margin.bottom, margin.top]);",
        "",
        "  // Add axes",
        "  svg.append(\"g\")",
        "      .attr(\"transform\", `translate(0,${height - margin.bottom})`)",
        "      .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0));",
        "",
        "  svg.append(\"g\")",
        "      .attr(\"transform\", `translate(${margin.left},0)`)",
        "      .call(d3.axisLeft(y1))",
        "      .call(g => g.select(\".domain\").remove())",
        "      .call(g => g.selectAll(\".tick line\").clone()",
        "          .attr(\"x2\", width - margin.left - margin.right)",
        "          .attr(\"stroke-opacity\", 0.1)) // Grid lines",
        "      .call(g => g.append(\"text\")",
        "          .attr(\"x\", -margin.left)",
        "          .attr(\"y\", margin.top - 15) // Position label above axis",
        "          .attr(\"fill\", \"steelblue\")",
        "          .attr(\"text-anchor\", \"start\")",
        "          .text(\"Attack Count\"));",
        "",
        "  svg.append(\"g\")",
        "      .attr(\"transform\", `translate(${width - margin.right},0)`)",
        "      .call(d3.axisRight(y2))",
        "      .call(g => g.select(\".domain\").remove())",
        "      .call(g => g.append(\"text\")",
        "          .attr(\"x\", margin.right) // Position relative to right margin",
        "          .attr(\"y\", margin.top - 15) // Position label above axis",
        "          .attr(\"fill\", \"orange\")",
        "          .attr(\"text-anchor\", \"end\")",
        "          .text(\"Profit (SOL)\"));",
        "",
        "  // Add lines",
        "  const line1 = d3.line()",
        "      .defined(d => !isNaN(d.count))",
        "      .x(d => x(d.date))",
        "      .y(d => y1(d.count));",
        "",
        "  const line2 = d3.line()",
        "      .defined(d => !isNaN(d.profit))",
        "      .x(d => x(d.date))",
        "      .y(d => y2(d.profit));",
        "",
        "  svg.append(\"path\")",
        "      .datum(chartData)",
        "      .attr(\"fill\", \"none\")",
        "      .attr(\"stroke\", \"steelblue\")",
        "      .attr(\"stroke-width\", 1.5)",
        "      .attr(\"d\", line1);",
        "",
        "  svg.append(\"path\")",
        "      .datum(chartData)",
        "      .attr(\"fill\", \"none\")",
        "      .attr(\"stroke\", \"orange\")",
        "      .attr(\"stroke-width\", 1.5)",
        "      .attr(\"d\", line2);",
        "",
        "  // Add title",
        "  svg.append(\"text\")",
        "      .attr(\"x\", width / 2)",
        "      .attr(\"y\", margin.top / 2) // Adjust title position",
        "      .attr(\"text-anchor\", \"middle\")",
        "      .style(\"font-size\", \"16px\")",
        "      .text(\"Sandwich Attacks Over Time\");",
        "",
        "  // Add legend (ensure it doesn't overlap title)",
        "  const legend = svg.append(\"g\")",
        "      .attr(\"transform\", `translate(${width - margin.right - 100}, ${margin.top})`); // Position below title",
        "",
        "  legend.append(\"rect\")",
        "      .attr(\"x\", 0)",
        "      .attr(\"width\", 15)",
        "      .attr(\"height\", 15)",
        "      .attr(\"fill\", \"steelblue\");",
        "",
        "  legend.append(\"text\")",
        "      .attr(\"x\", 20)",
        "      .attr(\"y\", 12.5)",
        "      .text(\"Attack Count\");",
        "",
        "  legend.append(\"rect\")",
        "      .attr(\"x\", 0)",
        "      .attr(\"y\", 20)",
        "      .attr(\"width\", 15)",
        "      .attr(\"height\", 15)",
        "      .attr(\"fill\", \"orange\");",
        "",
        "  legend.append(\"text\")",
        "      .attr(\"x\", 20)",
        "      .attr(\"y\", 32.5)",
        "      .text(\"Profit (SOL)\");",
        "",
        "  return svg.node();",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "dex-chart-cell",
        "language": "javascript"
      },
      "source": [
        "// Bar chart of sandwich attacks by DEX",
        "sandwichByDexChart = {",
        "  // Check filteredData readiness",
        "  if (!filteredData || !filteredData.length) return html`<p>No data available for DEX chart.</p>`;",
        "",
        "  // Group by DEX",
        "  const dexData = d3.rollup(",
        "    filteredData,",
        "    v => ({",
        "      count: v.length,",
        "      profit: d3.sum(v, d => +d.profit_sol || 0), // Ensure numeric sum",
        "      avgProfit: d3.mean(v, d => +d.profit_sol || 0) // Ensure numeric mean",
        "    }),",
        "    d => d.dex",
        "  );",
        "",
        "  // Convert to array for charting",
        "  const chartData = Array.from(dexData, ([dex, data]) => ({",
        "    dex,",
        "    count: data.count,",
        "    profit: data.profit,",
        "    avgProfit: data.avgProfit",
        "  })).sort((a, b) => b.count - a.count);",
        "",
        "  // Check if chartData has valid entries",
        "  if (!chartData || chartData.length === 0) return html`<p>No valid DEX data to plot.</p>`;",
        "",
        "  // Create the chart",
        "  const width = 600;",
        "  const height = 400;",
        "  const margin = {top: 40, right: 20, bottom: 60, left: 60};",
        "",
        "  const svg = d3.create(\"svg\")",
        "      .attr(\"width\", width)",
        "      .attr(\"height\", height);",
        "",
        "  const x = d3.scaleBand()",
        "      .domain(chartData.map(d => d.dex))",
        "      .range([margin.left, width - margin.right])",
        "      .padding(0.1);",
        "",
        "  const y = d3.scaleLinear()",
        "      .domain([0, d3.max(chartData, d => d.count)])",
        "      .nice()",
        "      .range([height - margin.bottom, margin.top]);",
        "",
        "  // Add axes",
        "  svg.append(\"g\")",
        "      .attr(\"transform\", `translate(0,${height - margin.bottom})`)",
        "      .call(d3.axisBottom(x))",
        "      .selectAll(\"text\")",
        "      .attr(\"transform\", \"rotate(-45)\")",
        "      .style(\"text-anchor\", \"end\");",
        "",
        "  svg.append(\"g\")",
        "      .attr(\"transform\", `translate(${margin.left},0)`)",
        "      .call(d3.axisLeft(y));",
        "",
        "  // Add bars",
        "  svg.selectAll(\"rect\")",
        "    .data(chartData)",
        "    .join(\"rect\")",
        "      .attr(\"x\", d => x(d.dex))",
        "      .attr(\"y\", d => y(d.count))",
        "      .attr(\"height\", d => y(0) - y(d.count))",
        "      .attr(\"width\", x.bandwidth())",
        "      .attr(\"fill\", \"steelblue\")",
        "      .append(\"title\")",
        "      .text(d => `${d.dex}\\nAttacks: ${d.count}\\nTotal Profit: ${(d.profit || 0).toFixed(2)} SOL\\nAvg Profit: ${(d.avgProfit || 0).toFixed(4)} SOL`); // Add checks for undefined",
        "",
        "  // Add title",
        "  svg.append(\"text\")",
        "      .attr(\"x\", width / 2)",
        "      .attr(\"y\", margin.top / 2)",
        "      .attr(\"text-anchor\", \"middle\")",
        "      .style(\"font-size\", \"16px\")",
        "      .text(\"Sandwich Attacks by DEX\");",
        "",
        "  // Add labels",
        "  svg.append(\"text\")",
        "      .attr(\"transform\", \"rotate(-90)\")",
        "      .attr(\"y\", margin.left / 3)",
        "      .attr(\"x\", -(height / 2))",
        "      .attr(\"text-anchor\", \"middle\")",
        "      .text(\"Number of Attacks\");",
        "",
        "  return svg.node();",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "pairs-chart-cell",
        "language": "javascript"
      },
      "source": [
        "// Bar chart of top token pairs affected by sandwich attacks",
        "topPairsChart = {",
        "  // Check filteredData readiness",
        "  if (!filteredData || !filteredData.length) return html`<p>No data available for token pairs chart.</p>`;",
        "",
        "  // Group by token pair",
        "  const pairData = d3.rollup(",
        "    filteredData,",
        "    v => ({",
        "      count: v.length,",
        "      profit: d3.sum(v, d => +d.profit_sol || 0), // Ensure numeric sum",
        "      avgProfit: d3.mean(v, d => +d.profit_sol || 0) // Ensure numeric mean",
        "    }),",
        "    d => d.token_pair",
        "  );",
        "",
        "  // Convert to array and sort",
        "  const chartData = Array.from(pairData, ([pair, data]) => ({",
        "    pair,",
        "    count: data.count,",
        "    profit: data.profit,",
        "    avgProfit: data.avgProfit",
        "  }))",
        "  .sort((a, b) => b.count - a.count)",
        "  .slice(0, 10);  // Top 10 pairs",
        "",
        "  // Check if chartData has valid entries",
        "  if (!chartData || chartData.length === 0) return html`<p>No valid token pair data to plot.</p>`;",
        "",
        "  // Create the chart",
        "  const width = 700;",
        "  const height = 400;",
        "  const margin = {top: 40, right: 20, bottom: 60, left: 60};",
        "",
        "  const svg = d3.create(\"svg\")",
        "      .attr(\"width\", width)",
        "      .attr(\"height\", height);",
        "",
        "  const x = d3.scaleBand()",
        "      .domain(chartData.map(d => d.pair))",
        "      .range([margin.left, width - margin.right])",
        "      .padding(0.1);",
        "",
        "  const y = d3.scaleLinear()",
        "      .domain([0, d3.max(chartData, d => d.count)])",
        "      .nice()",
        "      .range([height - margin.bottom, margin.top]);",
        "",
        "  // Add axes",
        "  svg.append(\"g\")",
        "      .attr(\"transform\", `translate(0,${height - margin.bottom})`)",
        "      .call(d3.axisBottom(x))",
        "      .selectAll(\"text\")",
        "      .attr(\"transform\", \"rotate(-45)\")",
        "      .style(\"text-anchor\", \"end\");",
        "",
        "  svg.append(\"g\")",
        "      .attr(\"transform\", `translate(${margin.left},0)`)",
        "      .call(d3.axisLeft(y));",
        "",
        "  // Add bars",
        "  svg.selectAll(\"rect\")",
        "    .data(chartData)",
        "    .join(\"rect\")",
        "      .attr(\"x\", d => x(d.pair))",
        "      .attr(\"y\", d => y(d.count))",
        "      .attr(\"height\", d => y(0) - y(d.count))",
        "      .attr(\"width\", x.bandwidth())",
        "      .attr(\"fill\", \"steelblue\")",
        "      .append(\"title\")",
        "      .text(d => `${d.pair}\\nAttacks: ${d.count}\\nTotal Profit: ${(d.profit || 0).toFixed(2)} SOL\\nAvg Profit: ${(d.avgProfit || 0).toFixed(4)} SOL`); // Add checks for undefined",
        "",
        "  // Add title",
        "  svg.append(\"text\")",
        "      .attr(\"x\", width / 2)",
        "      .attr(\"y\", margin.top / 2)",
        "      .attr(\"text-anchor\", \"middle\")",
        "      .style(\"font-size\", \"16px\")",
        "      .text(\"Most Frequently Sandwiched Token Pairs\");",
        "",
        "  // Add labels",
        "  svg.append(\"text\")",
        "      .attr(\"transform\", \"rotate(-90)\")",
        "      .attr(\"y\", margin.left / 3)",
        "      .attr(\"x\", -(height / 2))",
        "      .attr(\"text-anchor\", \"middle\")",
        "      .text(\"Number of Attacks\");",
        "",
        "  return svg.node();",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "attackers-chart-cell",
        "language": "javascript"
      },
      "source": [
        "// Bar chart of top sandwich attackers",
        "topAttackersChart = {",
        "  // Check filteredData readiness",
        "  if (!filteredData || !filteredData.length) return html`<p>No data available for attackers chart.</p>`;",
        "",
        "  // Group by attacker address",
        "  const attackerData = d3.rollup(",
        "    filteredData,",
        "    v => ({",
        "      count: v.length,",
        "      profit: d3.sum(v, d => +d.profit_sol || 0), // Ensure numeric sum",
        "      avgProfit: d3.mean(v, d => +d.profit_sol || 0) // Ensure numeric mean",
        "    }),",
        "    d => d.attacker_address",
        "  );",
        "",
        "  // Convert to array, sort, and take top 10",
        "  const chartData = Array.from(attackerData, ([attacker, data]) => ({",
        "    attacker: attacker.substring(0, 6) + \"...\" + attacker.substring(attacker.length - 4),",
        "    fullAddress: attacker,",
        "    count: data.count,",
        "    profit: data.profit,",
        "    avgProfit: data.avgProfit",
        "  }))",
        "  .sort((a, b) => b.profit - a.profit)",
        "  .slice(0, 10);",
        "",
        "  // Check if chartData has valid entries",
        "  if (!chartData || chartData.length === 0) return html`<p>No valid attacker data to plot.</p>`;",
        "",
        "  // Create the chart",
        "  const width = 700;",
        "  const height = 400;",
        "  const margin = {top: 40, right: 120, bottom: 60, left: 60};",
        "",
        "  const svg = d3.create(\"svg\")",
        "      .attr(\"width\", width)",
        "      .attr(\"height\", height);",
        "",
        "  const x = d3.scaleLinear()",
        "      .domain([0, d3.max(chartData, d => d.profit)])",
        "      .nice()",
        "      .range([margin.left, width - margin.right]);",
        "",
        "  const y = d3.scaleBand()",
        "      .domain(chartData.map(d => d.attacker))",
        "      .range([margin.top, height - margin.bottom])",
        "      .padding(0.1);",
        "",
        "  // Add axes",
        "  svg.append(\"g\")",
        "      .attr(\"transform\", `translate(0,${height - margin.bottom})`)",
        "      .call(d3.axisBottom(x).ticks(width / 80).tickFormat(d => d + \" SOL\"));",
        "",
        "  svg.append(\"g\")",
        "      .attr(\"transform\", `translate(${margin.left},0)`)",
        "      .call(d3.axisLeft(y));",
        "",
        "  // Add bars",
        "  svg.selectAll(\"rect\")",
        "    .data(chartData)",
        "    .join(\"rect\")",
        "      .attr(\"x\", margin.left)",
        "      .attr(\"y\", d => y(d.attacker))",
        "      .attr(\"width\", d => x(d.profit || 0) - margin.left) // Handle potential undefined profit",
        "      .attr(\"height\", y.bandwidth())",
        "      .attr(\"fill\", \"steelblue\")",
        "      .append(\"title\")",
        "      .text(d => `${d.fullAddress}\\nAttacks: ${d.count}\\nTotal Profit: ${(d.profit || 0).toFixed(2)} SOL\\nAvg Profit: ${(d.avgProfit || 0).toFixed(4)} SOL`); // Add checks for undefined",
        "",
        "  // Add profit labels",
        "  svg.selectAll(\".profit-label\")",
        "    .data(chartData)",
        "    .join(\"text\")",
        "      .attr(\"class\", \"profit-label\")",
        "      .attr(\"x\", d => x(d.profit || 0) + 5) // Handle potential undefined profit",
        "      .attr(\"y\", d => y(d.attacker) + y.bandwidth() / 2)",
        "      .attr(\"dy\", \"0.35em\")",
        "      .text(d => `${(d.profit || 0).toFixed(2)} SOL (${d.count} attacks)`); // Add checks for undefined",
        "",
        "  // Add title",
        "  svg.append(\"text\")",
        "      .attr(\"x\", width / 2)",
        "      .attr(\"y\", margin.top / 2)",
        "      .attr(\"text-anchor\", \"middle\")",
        "      .style(\"font-size\", \"16px\")",
        "      .text(\"Top Sandwich Attackers by Profit\");",
        "",
        "  return svg.node();",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "sandwich-anatomy-cell",
        "language": "javascript"
      },
      "source": [
        "// Detailed anatomy of a sandwich attack (illustration)",
        "sandwichAnatomyDiagram = {",
        "  const width = 800;",
        "  const height = 400;",
        "  const margin = {top: 40, right: 20, bottom: 40, left: 20};",
        "",
        "  const svg = d3.create(\"svg\")",
        "      .attr(\"width\", width)",
        "      .attr(\"height\", height);",
        "",
        "  // Timeline axis",
        "  const timelineY = height - margin.bottom;",
        "  const timelineStart = margin.left + 50;",
        "  const timelineEnd = width - margin.right - 50;",
        "",
        "  svg.append(\"line\")",
        "      .attr(\"x1\", timelineStart)",
        "      .attr(\"y1\", timelineY)",
        "      .attr(\"x2\", timelineEnd)",
        "      .attr(\"y2\", timelineY)",
        "      .attr(\"stroke\", \"black\")",
        "      .attr(\"stroke-width\", 2);",
        "",
        "  // Time points",
        "  const timePoints = [",
        "    { label: \"t0\", x: timelineStart, description: \"Initial State\" },",
        "    { label: \"t1\", x: timelineStart + (timelineEnd - timelineStart) * 0.25, description: \"Attacker's Front-run Buy\" },",
        "    { label: \"t2\", x: timelineStart + (timelineEnd - timelineStart) * 0.5, description: \"Victim's Transaction\" },",
        "    { label: \"t3\", x: timelineStart + (timelineEnd - timelineStart) * 0.75, description: \"Attacker's Back-run Sell\" },",
        "    { label: \"t4\", x: timelineEnd, description: \"Final State\" }",
        "  ];",
        "",
        "  // Add time markers",
        "  timePoints.forEach(point => {",
        "    // Vertical line",
        "    svg.append(\"line\")",
        "        .attr(\"x1\", point.x)",
        "        .attr(\"y1\", timelineY - 5)",
        "        .attr(\"x2\", point.x)",
        "        .attr(\"y2\", timelineY + 5)",
        "        .attr(\"stroke\", \"black\")",
        "        .attr(\"stroke-width\", 2);",
        "",
        "    // Time label",
        "    svg.append(\"text\")",
        "        .attr(\"x\", point.x)",
        "        .attr(\"y\", timelineY + 20)",
        "        .attr(\"text-anchor\", \"middle\")",
        "        .style(\"font-weight\", \"bold\")",
        "        .text(point.label);",
        "",
        "    // Description",
        "    svg.append(\"text\")",
        "        .attr(\"x\", point.x)",
        "        .attr(\"y\", timelineY + 35)",
        "        .attr(\"text-anchor\", \"middle\")",
        "        .style(\"font-size\", \"12px\")",
        "        .text(point.description);",
        "  });",
        "",
        "  // Price curve",
        "  const pricePoints = [",
        "    { x: timePoints[0].x, y: timelineY - 100 },  // Initial price",
        "    { x: timePoints[1].x, y: timelineY - 150 },  // Price after front-run (up)",
        "    { x: timePoints[2].x, y: timelineY - 200 },  // Price after victim trade (up more)",
        "    { x: timePoints[3].x, y: timelineY - 120 },  // Price after back-run (down)",
        "    { x: timePoints[4].x, y: timelineY - 110 },  // Final price",
        "  ];",
        "",
        "  // Create line function",
        "  const line = d3.line()",
        "      .x(d => d.x)",
        "      .y(d => d.y)",
        "      .curve(d3.curveMonotoneX);",
        "",
        "  // Draw price curve",
        "  svg.append(\"path\")",
        "      .datum(pricePoints)",
        "      .attr(\"fill\", \"none\")",
        "      .attr(\"stroke\", \"#2a9d8f\")",
        "      .attr(\"stroke-width\", 3)",
        "      .attr(\"d\", line);",
        "",
        "  // Price axis label",
        "  svg.append(\"text\")",
        "      .attr(\"transform\", \"rotate(-90)\")",
        "      .attr(\"y\", margin.left)",
        "      .attr(\"x\", -timelineY + 100)",
        "      .attr(\"text-anchor\", \"middle\")",
        "      .text(\"Token Price\");",
        "",
        "  // Transaction markers",
        "  const transactions = [",
        "    { time: timePoints[1].x, y: pricePoints[1].y, type: \"Front-run\", color: \"#e63946\" },",
        "    { time: timePoints[2].x, y: pricePoints[2].y, type: \"Victim Trade\", color: \"#000000\" },",
        "    { time: timePoints[3].x, y: pricePoints[3].y, type: \"Back-run\", color: \"#e63946\" }",
        "  ];",
        "",
        "  // Add transaction markers",
        "  transactions.forEach(tx => {",
        "    svg.append(\"circle\")",
        "        .attr(\"cx\", tx.time)",
        "        .attr(\"cy\", tx.y)",
        "        .attr(\"r\", 6)",
        "        .attr(\"fill\", tx.color);",
        "",
        "    svg.append(\"text\")",
        "        .attr(\"x\", tx.time)",
        "        .attr(\"y\", tx.y - 15)",
        "        .attr(\"text-anchor\", \"middle\")",
        "        .attr(\"fill\", tx.color)",
        "        .style(\"font-weight\", tx.type === \"Victim Trade\" ? \"normal\" : \"bold\")",
        "        .text(tx.type);",
        "  });",
        "",
        "  // Add price slippage annotation",
        "  svg.append(\"line\")",
        "      .attr(\"x1\", pricePoints[0].x + 10)",
        "      .attr(\"y1\", pricePoints[0].y)",
        "      .attr(\"x2\", pricePoints[2].x - 10)",
        "      .attr(\"y2\", pricePoints[2].y)",
        "      .attr(\"stroke\", \"#457b9d\")",
        "      .attr(\"stroke-width\", 1.5)",
        "      .attr(\"stroke-dasharray\", \"5,5\");",
        "",
        "  svg.append(\"text\")",
        "      .attr(\"x\", timePoints[0].x + 60)",
        "      .attr(\"y\", timelineY - 160)",
        "      .attr(\"text-anchor\", \"start\")",
        "      .style(\"font-size\", \"12px\")",
        "      .style(\"fill\", \"#457b9d\")",
        "      .text(\"Increased Price Slippage\");",
        "",
        "  // Add profit annotation",
        "  svg.append(\"line\")",
        "      .attr(\"x1\", pricePoints[1].x + 10)",
        "      .attr(\"y1\", pricePoints[1].y)",
        "      .attr(\"x2\", pricePoints[3].x - 10)",
        "      .attr(\"y2\", pricePoints[3].y)",
        "      .attr(\"stroke\", \"#e63946\")",
        "      .attr(\"stroke-width\", 1.5)",
        "      .attr(\"stroke-dasharray\", \"5,5\");",
        "",
        "  svg.append(\"text\")",
        "      .attr(\"x\", timePoints[2].x)",
        "      .attr(\"y\", timelineY - 170)",
        "      .attr(\"text-anchor\", \"middle\")",
        "      .style(\"font-size\", \"12px\")",
        "      .style(\"fill\", \"#e63946\")",
        "      .style(\"font-weight\", \"bold\")",
        "      .text(\"Attacker's Profit\");",
        "",
        "  // Add title",
        "  svg.append(\"text\")",
        "      .attr(\"x\", width / 2)",
        "      .attr(\"y\", margin.top / 2)",
        "      .attr(\"text-anchor\", \"middle\")",
        "      .style(\"font-size\", \"18px\")",
        "      .style(\"font-weight\", \"bold\")",
        "      .text(\"Anatomy of a Sandwich Attack\");",
        "",
        "  return svg.node();",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "data-table-cell",
        "language": "javascript"
      },
      "source": [
        "// Data table of recent sandwich attacks",
        "viewof attacksTable = Inputs.table(",
        "  // Check filteredData readiness before slicing",
        "  (filteredData && filteredData.length > 0) ? filteredData.slice(0, 20) : [],",
        "  {",
        "    columns: [",
        "      \"timestamp\",",
        "      \"token_pair\",",
        "      \"dex\",",
        "      \"victim_tx\",",
        "      \"profit_sol\",",
        "      \"profit_usd\",",
        "      \"slippage_pct\"",
        "    ],",
        "    width: {",
        "      victim_tx: 200,",
        "      timestamp: 180",
        "    },",
        "    format: {",
        "      profit_sol: x => x !== undefined && x !== null ? (+x).toFixed(4) : 'N/A',",
        "      profit_usd: x => x !== undefined && x !== null ? `$${(+x).toFixed(2)}` : 'N/A',",
        "      slippage_pct: x => x !== undefined && x !== null ? `${(+x).toFixed(2)}%` : 'N/A',",
        "      timestamp: x => x ? new Date(x).toLocaleString() : 'N/A'",
        "    },",
        "    sort: \"timestamp\",",
        "    reverse: true",
        "  }",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "explanation-cell",
        "language": "markdown"
      },
      "source": [
        "## Understanding Sandwich Attacks in DEX Trading",
        "",
        "Sandwich attacks are a type of front-running attack that exploit how decentralized exchanges execute trades. These attacks target pending transactions in the mempool, extracting value from unsuspecting traders through price manipulation.",
        "",
        "### How Sandwich Attacks Work",
        "",
        "1. **Detection**: Attackers monitor the mempool for pending transactions on decentralized exchanges.",
        "",
        "2. **Front-running**: Upon detecting a large swap, the attacker quickly submits their own transaction with a higher gas fee to execute first, buying the target asset.",
        "",
        "3. **Price Impact**: The victim's transaction executes after the attacker's, but now at a worse price due to the attacker's front-running purchase moving the price up.",
        "",
        "4. **Back-running**: Immediately after the victim's transaction, the attacker sells the assets they just purchased, profiting from the price difference.",
        "",
        "### Impact on Victims",
        "",
        "- **Increased Slippage**: Victims receive fewer tokens than expected due to the artificial price movement.",
        "- **Failed Transactions**: If slippage exceeds the victim's tolerance settings, transactions may fail entirely.",
        "- **Market Distortion**: Regular trading becomes more expensive and unpredictable for all users.",
        "",
        "### Prevention Strategies",
        "",
        "1. **Slippage Protection**: Set reasonable slippage tolerances to protect against extreme price manipulation.",
        "2. **Private RPC Endpoints**: Use private transaction relays that protect transactions from front-running.",
        "3. **MEV-Aware Routing**: Use DEX aggregators with MEV protection features.",
        "4. **Transaction Timing**: Avoid trading during periods of high congestion when sandwich attacks are more profitable.",
        "",
        "The analysis in this notebook helps identify patterns in sandwich attacks on Solana, revealing the most targeted pairs, common attack strategies, and their economic impact on the ecosystem."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "export-format-cell",
        "language": "javascript"
      },
      "source": [
        "// Export functionality",
        "viewof exportFormat = Inputs.radio(",
        "  [\"JSON\", \"CSV\", \"PNG\"],",
        "  {value: \"JSON\", label: \"Export Format\"}",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "export-button-cell",
        "language": "javascript"
      },
      "source": [
        "viewof exportButton = Inputs.button(\"Export Data\")"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "export-data-cell",
        "language": "javascript"
      },
      "source": [
        "// Export handling",
        "exportData = {",
        "  // Trigger this cell when exportButton changes",
        "  exportButton; // Reference the button to make this cell reactive to it",
        "",
        "  if (exportFormat === \"JSON\") {",
        "    const dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(filteredData));",
        "    const downloadLink = document.createElement(\"a\");",
        "    downloadLink.setAttribute(\"href\", dataStr);",
        "    downloadLink.setAttribute(\"download\", \"sandwich_attacks.json\");",
        "    downloadLink.click();",
        "    return \"Data exported as JSON\";",
        "  } else if (exportFormat === \"CSV\") {",
        "    if (!filteredData || filteredData.length === 0) {",
        "        return \"No data to export.\";",
        "    }",
        "    let csvContent = \"data:text/csv;charset=utf-8,\";",
        "",
        "    // Add header",
        "    const headers = Object.keys(filteredData[0]);",
        "    csvContent += headers.join(\",\") + \"\\r\\n\";",
        "",
        "    // Add rows",
        "    filteredData.forEach(row => {",
        "      const values = headers.map(header => {",
        "        const value = row[header];",
        "        // Handle commas and quotes in string values",
        "        let formattedValue = (value === null || value === undefined) ? '' : value;",
        "        if (typeof formattedValue === 'string') {",
        "            formattedValue = `\"${formattedValue.replace(/\"/g, '\"\"')}\"`; // Escape double quotes",
        "        }",
        "        return formattedValue;",
        "      });",
        "      csvContent += values.join(\",\") + \"\\r\\n\";",
        "    });",
        "",
        "    const encodedUri = encodeURI(csvContent);",
        "    const downloadLink = document.createElement(\"a\");",
        "    downloadLink.setAttribute(\"href\", encodedUri);",
        "    downloadLink.setAttribute(\"download\", \"sandwich_attacks.csv\");",
        "    downloadLink.click();",
        "    return \"Data exported as CSV\";",
        "  } else if (exportFormat === \"PNG\") {",
        "    // This would be implemented with additional libraries in a real environment",
        "    return \"PNG export not implemented in this example\";",
        "  }",
        "  return \"\"; // Return empty string if button hasn't been clicked yet",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "sample-data-cell",
        "language": "javascript"
      },
      "source": [
        "// Sample data for testing",
        "sandwichSampleData = [",
        "  {",
        "    \"timestamp\": \"2023-10-10T08:23:14Z\",",
        "    \"dex\": \"Jupiter\",",
        "    \"token_pair\": \"SOL/USDC\",",
        "    \"attacker_address\": \"SandwichBotA1111111111111111111111111111111\",",
        "    \"victim_address\": \"Victim111111111111111111111111111111111111\",",
        "    \"victim_tx\": \"43Aq9r2UX2tz2U6KL7u89qt8xdg4yWr8GaqNDVGvw4y5BxbmL3H2x3Ds4JoyzjrR82Q4guioGuiXZ5A7GZtHE3SC\",",
        "    \"front_tx\": \"5y3p88VbfEMAwLzwi6uWxhXsuyVnBcXs8GoiiqCTGV6UTarUo88H7TvQrVCQCQZmxQXHZsf1brtPMXW9JJR5kyYA\",",
        "    \"back_tx\": \"2SbKbW7ikPBUx8CvzBoqBsAjdkMSALUUmabfnpyZK2KQdjwvgaEXJQYkDRnXqX3iNFhjKDXfr2FvLa9KE3tELFww\",",
        "    \"profit_sol\": 0.28,",
        "    \"profit_usd\": 16.80,",
        "    \"slippage_pct\": 0.92,",
        "    \"block_time\": 1696930994,",
        "    \"slot\": 211455678",
        "  },",
        "  // ...more sample data entries...",
        "  // Other sample data objects follow the same structure",
        "  {",
        "    \"timestamp\": \"2023-09-20T11:37:18Z\",",
        "    \"dex\": \"Jupiter\",",
        "    \"token_pair\": \"SOL/USDC\",",
        "    \"attacker_address\": \"SandwichBotD4444444444444444444444444444444\",",
        "    \"victim_address\": \"VictimLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL\",",
        "    \"victim_tx\": \"3Y7W4xrxq31nxWMSqARjAJAdUZgMJYvLeTYYqJ4r8TFMzxe7vLQdxSFNMqYQEfVsKo3N1vJ8WoRK8kygfxWwCFBp\",",
        "    \"front_tx\": \"3bTFryzDRPmfqP4QbZG8JwfRqmaeKkEYFftDeZDXSYr9J1T7Jw9M4m5uVMFqpvKqeVZZAD9VZe1qTHmLTCqmXHuH\",",
        "    \"back_tx\": \"5TJREwF8TPGefBiPQzWsTeKuBwjwNpPYYj72vViMmFxsxCDw8KQbwCbCwAQ1Cwd2Vt9H8CRNedQvemQBVVnQZAkH\",",
        "    \"profit_sol\": 0.76,",
        "    \"profit_usd\": 45.60,",
        "    \"slippage_pct\": 1.88,",
        "    \"block_time\": 1695217038,",
        "    \"slot\": 206745625",
        "  }",
        "]"
      ]
    }
  ]
}